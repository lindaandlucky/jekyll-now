# 函数的扩展

## 函数参数的默认值

### 基本用法

ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。

```javascript
function log(x, y = 'World') {
  console.log(x, y);
}

log('Hello') // Hello World
log('Hello', 'China') // Hello China
log('Hello', '') // Hello
```

除了简洁，ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。

参数变量是默认声明的，所以不能用`let`或`const`再次声明。

使用参数默认值时，函数不能有同名参数。

另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。

```javascript
let x = 99;
function foo(p = x + 1) {
  console.log(p);
}

foo() // 100

x = 100;
foo() // 101
```

上面代码中，参数`p`的默认值是`x + 1`。这时，每次调用函数`foo`，都会重新计算`x + 1`，而不是默认`p`等于 100。

### 与解构赋值默认值结合使用

参数默认值与解构赋值的默认值结合起来使用

```js
function foo({x,y = 5}) {
  console.log(x,y)
}
foo({})  // undefined 5
foo({x:1}) // 1,5
foo({x:1,y=2}) // 1 2
foo()// TypeError: Cannot read property 'x' of undefined
// 这段参数值使用了对象的解构赋值默认值，没哟使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会痛殴解构赋值形成。如果函数foo调用时没有提供参数，变量x和y就不会生成，从而报错。
// 通过提供函数参数的默认值，就可以避免这样的情况
function foo({x,y=5}={}) {
  console.log(x,y)
}
foo() // undefined 5
//上面代码指定，如果没有提供参数，函数foo的参数默认为一个空对象
```

```js
function fetch (url,{body="",method="Get",headers={}}) {
  console.log(method)
}
fetch('http://example.com',{}) //"Get"
fetch('http://example.com') // 报错
// 该函数第二个参数是一个对象，就可以为它的三个属性设置默认值。这样写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数，此时，就出现了双重默认值

```


 2019-02-15-node.md

运行在浏览器内核的js引擎上，事件驱动，非阻塞I/O模型

语言的能力取决于平台是否支持，node有点像js的虚拟机

注意： 是node选择了js,不是js发展成了node

 用途： 分发数据请求，渲染html页面 

函数执行的方式： 一种是用括号的方式执行，另一种是将函数赋值给一个变量





### 全局对象

```js
node —use_strict    启用严格模式
node -e "要执行的js代码"。用来执行脚本
_  代表上一层的返回结果

global：
---类似于客户端js的window
process：
---获取当前的node进程信息，一般用于获取环境变量之类的信息
----process.stdout.write("要在控制台输出的内容") 以面向对象的方式输出了控制台，打印出来的不换行
----process.stdin // 标准输入，当命令行中有回车符的时候触发
----process.stdout.getWindowSize()  // 获取窗口的宽度和高度
----process.on("SIGINT",()=>{})   
console：
---node 的内置console模块，提供操作控制台的输入输出功能，使用方式类似于客户端，
---在node中可以使用console ,是node的console，并不是客户端的console
```

### node调试工具

```js
# node 原生调试工具
node debug 要调试的文件
watch（要调试的变量） 监视变量的变化
# 第三方提供的调试工具
   npm install node-inspector -g
   npm install devtool -g

```





## js语法

```bash

  1.交互式运行环境--REPL
    如何进入REPL环境：在控制台直接输入node
	如何退出REPL环境：连续两次按CTRL+C    或者输入.exit
	## node.js命令需要在前面加点
	## .help 查看所有命令
  2.浏览器运行环境--Chrome
    打开开发者工具
  3.数据类型
   有两种：简单数据类型 undefined boolean number string null
          复杂数据类型 object
   (1)利用typeof区分数据类型
   		# null和object都返回了object，这是因为null实际上是一个空对象指针
   (2)利用Boolean()转化数据类型
       # 空字符串 0 null undefined NaN    都会转化为false
       # 其他值都会转化为true
  4.函数
    函数中默认带有一个arguments对象，这是个类数组对象，它纪录了传递给函数的参数信息，因为js中的函数调用时，参数的个数和定义的函数的个数不一致时，函数仍会正常执行
    # 利用js中的arguments类数组对象模拟函数重载，实际上就js并不支持函数重载，比如通过检测对象的length属性做出不同的反应来模拟重载
    # 因为arguments并不是真正的数组对象，只是与数组类似而已，所以它并没有slice这个方法，而Array.prototype.slice.call(arguments)可以理解成是让arguments转换成一个数组对象，让arguments具有slice()方法。要是直接写arguments.slice(1)会报错。
   5. 闭包
   js中的函数可以读取到全局变量，而函数外部读取不到函数内部定义的变量
   js的闭包也可以让函数读取到其他函数中的变量,请看下面的代码
  
```

```javascript
function a(){
    var str='node.js';
    return function() {
        var str2= str+"is powerful";
        return str2;
    }
}
a()();
// node.js is powerful
```

## Node.js中的包管理

### NPM 介绍

常用命令

```javascript
npm -v   npm version // 查看npm的安装版本
npm init // 生成package.json的文件，这个文件是整个项目的描述文件，这个文件记载了项目的包依赖关系，版本，作者等信息
npm init -y // 默认生成package.json
npm install // 安装命令包
npm install --save // 安装包
npm install -dev // 安装开发阶段的包
npm uninstall // 卸载包
```

### 模块加载原理与加载方式

node.js的模块可以分为原生模块和文件模块，通过require来引入模块，exports来导出模块

1 require导入模块

```bash
# 对于原生模块，只需要使用require进入即可，加载模块时可以省略.js的扩展名
```

2 exports导出模块

```bash
# 如果想与其他模块共享一些方法和属性，使用exports导出一个对象
导出：module.expots = 对象
引用： require（"模块名称"）
```

## Node.j核心模块

### http模块---创建http服务器，客户端

```javascript
1. node.js服务器端
    http.createServer()返回的事http模块封装的一个基于事件的http服务器
    httpServer的事件：
     	request 当客户端请求到来时，该事件被触发，提供req和res参数，表示请求和响应信息
     	connection 当TCP连接建立时，该事件被触发，提供一个socket参数，是.net.Socket的实例
     	close  当服务器关闭时触发（注意不是在用户断开连接时）
    http.IncomingMessage是http请求的信息
         data: 当请求体数据到来时触发，提供chunk参数，表示接受的数据
         end: 请求体数据传输完毕触发
         close： 用户请求结束触发
    http.ServerResponse是返回给客户端的信息
         res.writeHead(statusCode,【heasers】)
         res.write(data,[encoding])
         res.end(data,[encoding])
2. 客户端向http服务器发起请求
   http.request(option):option 是个json对象，主要字段有host,port ,method,path,headers该方法返回一个httpClientRequest实例
   利用http.get()方法可以实现同样的效果
   与服务端一样，http.request()和http.get()返回的是http.ClientRequest()实例
   http.ClientRequest()类主要的事件和方法有：
      response 接受响应时触发
      request.write(chunk,[encoding],[callback]) 发送请求数据触发
      res.end([data],[endcoding],[callback])  发送请求完毕触发
```

```javascript
// 注意： 执行node脚本时，会出现这样的报错
events.js:71
throw arguments[1]; // Unhandled 'error' event
^
Error: connect ECONNREFUSED
at errnoException (net.js:770:11)
at Object.afterConnect [as oncomplete] (net.js:761:19)
这主要由于上一次node.js server进程仍然还在运行没关闭掉，所以我们需要杀掉此进程，在mac上操作为：
ps aux | grep node

twer 7668 4.3 1.0 42060 10708 pts/1 Sl+ 20:36 0:00 node server 
twer 7749 0.0 0.0 4384 832 pts/8 S+ 20:37 0:00 grep --color=auto node

从输出可以看见进程PID7668在使用，所以我们必须杀掉这顽固分子，运行kill -9 7668，一键搞定，可以重新开启server了。
//查看进程：ps
//结束进程：kill +进程PID
//强制结束进程：kill -9+进程PID
// 查看端口占用情况 ：lsof -i tcp:端口号

```

### url模块--URL地址处理---分析解析url

​	在文件中通过require('url')引入就可以

​       该模块提供了3种方法：

​              url.parse(url)    解析一个url地址，返回URL对象

​              Url.format(urlObj).  接受一个url对象为参数，返回完整的url地址

​               Url.resolve(from,to) 接受一个base url对象和一个href url对象，像浏览器一样返回一个完整的地址

### queryString模块—查询字符串处理

在文件中引入require('querystring')即可

 该模块提的几种方法：

​              querystring.parse()    将查询字符串反序列化为一个对象，类似JSON.parse（）

​              querystring.stringify()  将一个对象序列化为一个字符串，类似JSON.stringify() 

## Node.js常用模块

### util模块---实用工具

这是一个工具模块

提供以下主要方法

   ```javascript
util.inspect()   // 返回一个对象反序列化形成的字符串,这个方法在调试时非常有用，因为在控制台可以输出样式和风格，有利于区分数据，只需要在这个方法后加一个json对象参数，将color设置为true
util.formet()  // 返回一个使用占位符格式化的字符串,如果参数<占位符，那么多余的占位符不会被替换
               //参数>占位符，剩余参数通过util.inspect()转换成字符串
              // 没有占位符，以空格分割各个参数并拼接成字符串
util.log()    // 在控制台输出，类似于console.log，但是这个方法提供时间戳
util.isArray()  util.isRegExp()  util.isDate()// 判断数据类型的方法
   ```

### path模块 ---路径处理

这是处理文件路径的工具

提供以下主要方法

```javascript
path.join()  // 将所有的参数连接起来，返回一个路径
path.extname() // 返回路径参数的扩展名，无扩展名时返回空字符串
path.parse() // 将路径解析为一个路径对象
path.format() // 接受一个路径对象作为参数，返回一个完整的路径地址
```

### dns模块——域名处理和域名解析

提供以下主要方法

```javascript
dns.resolve()  // 将一个域名解析为一个指定类型的数组
dns.lookup()    // 返回第一个被发现的IPv4或者IPv6的地址
dns.reverse()   // 通过IP解析域名
```

## 文件系统

### 文件系统介绍

```javascript
1.同步和异步
异步方法的最后一个参数总是一个完整的回调函数，传递给回调函数的参数一般取决于这个方法本身，但是第一个参数永远是异常（err).如果方法执行成功，第一个参数是null或者undefined。当执行同步方法时，任何异常都会被立刻引发，我们可以使用try或者catch来处理异常并将错误信息显示出来
```

```javascript
2. fs模块中的类和文件的基本信息
    一共有4个类：
    fs.FSWatch // 获取文件相关信息
    fs.ReadStream // 读取流
    fs.WriteStream // 写入流 
	fs.Stats //获取文件相关信息
# fs.Stats这个类中提供了一些方法：
  stats.isFile()  // 标准文件返回true
  stats.isDirectory() // 目录返回true
  stats.isBlockDevice() // 块设备返回true
  stats.isCharacterDveice() // 字符设备返回true
  stats.isSynbolicLink() // 符号连接返回true
  stats.isFIFO()// FIFO返回true
  stats.isSocket() // UNIX套接字返回true
```

```javascript
3. 文件路径
node.js访问文件可以使用绝对路径和相对路径访问
用path模块修改连接，解析路径，转换路径，规范化路径 ，查找路径之间的关系，提取路径中的部分内容
path.normalize（路径字符串）来规范路径
path.join('','')来连接任意多个路径字符串
path.relative('','')找出一个绝对路径到另一个绝对路径的相对关系
# 在使用相对路径的时候，路径的相对性应该与process.cwd()一致
#   NodeJs中process.cwd()与__dirname的区别
	process.cwd() 是当前执行node命令时候的文件夹地址 ——工作目录，保证了文件在不同的目录下执行时，路径始	终不变
	__dirname 是被执行的js 文件的地址 ——文件所在目录

	Nodejs官方文档上的解释：

	=> process.cwd(): The process.cwd() method returns the current working directory of 	the Node.js process.

	意思很明了啦，就是说process.cwd()返回的是当前Node.js进程执行时的工作目录

	那么来看看__dirname的官方解释：

	=> __dirname: 当前模块的目录名。 等同于 __filename 的 path.dirname()。__dirname 实际上不是一	个全局变量，而是每个模块内部的
```

### 基本文件操作

```javascript
1 打开文件
fs.open(path, flags[,mode], callback)
参数说明： path： 文件路径
         flags： 文件打开方式
         mode：设置文件权限
         callback： 回调函数，有两个参数
```

```javascript
2 关闭文件
fs.closeSync // 同步操作的方法
fs.close(fd, callback)     // 异步操作的方法
异步操作的方法的参数说明：
   fd： 通过fs.open（）方法返回的文件描述符
   callback： 回调函数，没有参数
# 并不需要经常使用fs.close（）来关闭文件，除了几种特例外，node.js在进程退出后会自动将所有的文件关闭
```

 ```javascript
3 读取文件
fs.read(fd, buffer, offset,length, position,callback)
参数说明： fd： 通过fs.open()方法返回的文件描述符
         buffer： 数据写入的缓存区
         offset：缓存区写入的写入偏移量
         length： 要从文件中读取的字节数
         position：文件读取的起始位置，如果position的值为null，就会从当前文件指针的位置读取
         callback: 回调函数
 fs.readFile(filename,[,options],callback)
参数说明： filename： 要读取的文件
         options： 一个包含可选值的对象
                  包含两个 encoding{String|Null} 默认为null
                  flag {String}  默认为"r"
         callback: 回调函数
# fs.readFile是在fs.read上的进一步封装，两个的主要区别是fs.readFile方法只能读取文件的全部内容
 ```

```javascript
# js文件必须保存为utf8编码格式。使用node开发时，无论是代码文件还是要读取的文件都建议使用utf8编码格式，这样就无须额外的模块支持
```

### 写入文件

```javascript
fs.writeFile(filename,data[,options],callback)
参数说明： path： 文件路径
         data： 写入文件的数据，可以是字符串或者Buffer（流对象）
         options: 该参数是一个对象
         		包含{encoding,mode,flag},默认编码为Utf-8,模式为0666，flag为"w"
         callback: 回调函数，只包含错误信息
fs.appendFile(file, data[,options], callback)
参数说明： path： 文件名或者文件描述符=
         data： 写入文件的数据，可以是字符串或者Buffer（流对象）
         options: 该参数是一个对象
         		包含{encoding,mode,flag},默认编码为Utf-8,模式为0666，flag为"w"
         callback: 回调函数，只包含错误信息
```

### 其他文件操作

通过第三方包来对文件进行操作

## node.js网络开发

### 构建TCP服务器



```javascript
1. 构建TCP服务器
  var net = require('net')
  net.createServer([options],[,connectionListener])
参数说明：
         options: 该参数是一个对象
         		allowHalfOpen   默认为false
                pauseOnConnect  默认为false
         connectionListener:客户端和服务端家里连接时的回调函数，这个函数以socket端口对象作为参数
2. 监听客户端的连接
  server.listen(port,[,host][,backlog][,callback])
参数说明： port： 需要监听的端口号，参数为0时随机分配端口号
         host： 服务器地址
         backlog: 连接等待队列的最大长度
         callback: 回调函数
  # TCP还支持以下事件：
    connection  有新的连接创建时触发
    close     服务器关闭时触发
    error     服务器发生错误时触发
3.  查看服务器监听的地址
  server.address()返回一个json对象，对象的属性有
     port:TCP监听的端口号
     family: 说明监听的地址是Ipv6还是Ipv4
     address: 监听的地址
4.   连接服务器的客户端数量
   server.getConnections（）  // 这是个异步方法，它的回调函数有2个参数，第一个参数为error,第二方为连接服务器的客户端数量
   server.maxConnection 属性来设置tcp服务器的最大连接数，当连接数量超过最大连接数量时，服务器将拒绝新的连接
5. 获取客户端发送的数据
	net.createServer([options],[,connectionListener])
   connectionListener这个回调函数的参数net.Socket对象（服务器监听的端口对象），这个对象同样也有address()方法，来获取来获取服务器绑定的地址，同样含有port,famliy,address属性
   Socket对象用来获取客户端发送的流数据，有以下几个事件
      data,connect,end,error,timeout
6. 发送数据给客户端
 sokcet.write()可以使TCP服务器发送数据，有一个必须的参数，就是要给客户端发送的数据，第二个参数就是格式编码，同时为这个方法设置一个回调函数
 socket.localPort   本地端口地址
 socket.localAddres   本地Ip地址
 socket.remotePort  远程端口地址
socket.remoteFamliy   远程IP协议族
socket.remoteAddress   远程的ip地址
```

### 构建TCP客户端

```javascript
1. 使用node.js创建TCP客户端
   var net = require('net');
   var client = new net.socket();
   可以传入一个json对象，这个对象有以下属性
   fd： 文件描述符，默认值为null
   readable 是否允许在socket上读，默认为false
   writeable 是否允许在socket上写，默认为false
   allowHalfOpen 当属性为false，TCP服务器接收到客户端的发送的一个FIN包后回发一个FIN包，如果是true，则不会返回
2. 连接TCP服务器
var net = require('net');
var client = net.Socket()
client.connect(18001,"127.0.0.1",function() {
    console.log('connect the server')
})
3 获取从TCP服务器服务器发送的数据
var net = require('net');
var client = net.Socket();
client.connect(18001,"127.0.0.1", function() {
    console.log('connect the server')
})
client.on('data',function(data){
    console.log(data.toString())
})
4 向TCP服务器发送数据
var net = require('net');
let client = net.Socket();
client.connect(18001,"127.0.0.1",function() {
    console.log('connect the server')
    client.write('message from client')
})
client.on('data', function(data) {
    console.log('the data fo server is'+data.toString())
})
client.end('end',function () {
    console.log('data end')
})
```

## 构建http服务器

```javascript
1. 构建http服务器
var http = require('http');
var fs = require('fs');
var server = http.createServer(function(req,res){
    res.writeHead(200,{
        "content-type":'text/html'
    })
    var data = fs.readFileSync('./index.html');
    res.write(data);
    res.end();
})
server.listen(3000,function(){
    console.log('listening port 3000index')
})
# content-type用来表示客户端或服务器传输数据的类型，他们通过这个值来做相应的解析
2 http服务器的路由控制
var http = require('http');
var fs = require('fs');
var url = require('url');
var mime = require('./mime');
var path = require('path');
var server = http.createServer(function(req,res){
    var filePath = "."+ url.parse(req.url).pathname;
    if (filePath==="./") {
        filePath = "./index.html"
    }
    fs.exits(filePath,function(exit){
        if (exit) {
            var data = fs.readFileSync(filePath);
            var contetType = mime[path.extname(filePath)];
            res.writeHead(200,{
                "content-type":contetType
            })
            res.write(data);
            res.end()
        }else{
            res.end('404')
        }
    })
})
server.listen(3000,function() {
    console.log('listening port 3000')
})
```

### 利用UDP协议传输数据和发送消息—非连接协议

```javascript
1. 创建UDP服务器
var dgram = require('dgram');
var socket = dgram.createSocket('udp4',function(msg, rinfo){
    // your code
})
 参数说明：
 udp4 是必选参数，指定协议的类型
 msg  接受到的数据
 rinfo对象的属性和属性值如下：
 address     发送者地址
 family      发送者使用的地址"ipv4“或者”ipv6"
 port    发送者的端口号
 size    发送数据的字节数大小
 # createSocket 返回一个socket对象，主要有以下几个事件：
 message    接受数据时触发
 listening   开始监听数据报文时触发
 close   关闭socket时触发
 error   发生错误时触发
 
 socket.bind(41234,"localhost", function() {
 
 })
    一个socket对象有以下方法：
    bind()  绑定端口号
    send() 发送数据
    address()  获取改socket端口对象相关的信息地址
    close()   关闭socket对象
```

## node.js数据库开发

### 使用mongoose连接mongodb

```javascript
1.mongoDB介绍和安装
   非关系型数据库
2. 使用mongoose连接mongoDB
     mongoose是node.js驱动，方便在异步环境中操作
     # 安装这个模块 npm install mongoose 
     mongoose 通过connect（）中第一个参数是uri地址，也就是数据库地址const mongoose  = require('mongoose方法与mongoDB连接，connect（）中第一个参数是uri地址，也就是数据库地址
const mongoose = require('mongoose")
const uri = "mongodb://localhost/article"
                                                                       mongoose.connect(uri,function(err) {
         if(err) {
             console.log("connect failed")
             return ;
         }
         console.log('connect success')
     })
3. 使用mongoose操作mongoDB
mongoose中的schema开始。schema是一个以文件形式存储的数据库模型骨架，并不具备数据库的操作能力
schema定义了model中的所有属性
const mongoose = require('mongoose');
const uri = "mongodb://localhost/articel";
mongoose.connect(uri, function(err) {
    if(err) {
        console.log('connect failed');
        console.log(err);
        return;
    }
    console.log('connect success')
})
const ArticleSchema = new mongoose.Scheme({
    title: String,
    atuthor: String,
    content:String,
    publishTime: Date
})
mongoose.model('Article', ArticleSchema)
```


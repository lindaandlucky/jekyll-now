# 页面性能优化

前端性能优化分为两大部分：浏览器部分，代码部分

浏览器部分分为 网络层面。    浏览器层面。    服务端层面

代码部分有：构建层面，编码层面，ssr服务器端渲染，规范

## 浏览器是多进程的

渲染进程决定了浏览器的加载速度，默认每个tab都是一个进程，互不影响，主要作用就是为页面渲染，脚本执行，事件处理

GUI线程解析html,css ,构建dom树，页面重绘或者由于某些操作造成回流，该线程就会执行，与js线程互斥

js引擎负责处理js脚本，脚本要放在body下面，否则导致页面渲染加载阻塞

事件触发线程管理着事件队列

定时触发器线程

异步http请求线程

**浏览器的渲染流程**

DOM树构建

CSSOM树构建（css加载不会阻塞dom树解析（异步加载时dom树照常构建），但是会阻塞render树的渲染（渲染时需等待css加载完毕，因为render树需要css信息））

RenderObject树构建

布局

绘制

# 重排和重绘

如何减少重排和重绘

1. js尽量减少访问dom节点和css属性

2. 减少不必要的dom层级

3. 不要通过父级来改变子元素样式，最好直接改变子元素的样式

4. 尽量通过class来设计元素样式，切记用style多次操作单个属性

5. 尽可能为产生动画的元素使用固定定位或者绝对定位，这样的话修改css不会reflow

6. img标签要奢姿宽高，以减少重绘重排

7. 把dom离线后修改，如将一个dom脱离文档流，比如display；none.再修改属性，这里只发生一次回流

8. 尽量用transform来做形变和位移，不会造成回流

9. 权衡速度的平滑，比如实现一个动画，以一个像素为单位这样最平滑，但是reflow就会过于频繁，cpu很快会被完全占用，如果以3个像素为单位移动就会好很多

10. 不要用tables布局的另一个原因就是tables中某一个元素一旦触发reflow就会导致tables里所有的其他元素reflow。在适合用table的场合，可以设置table-layout为auto或者fixed

11. 避免不必要的复杂的css选择器

    总结：重排：元素的尺寸变了，位置变了

    ​          重绘： 元素的颜色背景，边框，轮廓变了，但是元素的几何尺寸没有变

    重排比重绘的成本要高很多

# 优化原则



1。减少http请求

2 使用内容传送网络CDN

3 避免空src或者href空值

4 gzip的组件

5css放在头部，js放在底部，scripts 添加defer或者async属性

6减少dns的查找

7.压缩资源

8避免重定向或找不到资源

9ajax优化，使ajax可缓存

10cookie优化

  减少cookie大小，对一些静态资源不需要使用cookie的氮素设置域

11 利用缓存

12 缩短服务器响应时间

13 图片。css放在二级域名下

**浏览器的并发请求数目限制是针对同一域名的（例如向www.baidu.com发送请求）。即一时间针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。**

多域名可以分散cookie，在社交网站中这个很重要

高性能浏览器支持的并发请求多，但是如果是ie或者更低版本的并发请求会比较少，所以二级域名的配置会比较重要，这块的优化主要集中在nginx的配置上面

# 优化工具

Google Page Speed

jsPerf&Benchmark.js



**ESlint**没有加入，钩子函数确实，美化**preitter**缺失

导致**css**换乱，**js**书写问题模块化问题突出

项目前期的规范性较差，忽略开发前期准备工作，缺乏全局组件的封装工作，造成开发人员在全局组件开发方面各自为政，缺乏引导性，也造成部分代码冗余

**less**插件使用并没有发挥它的作用，全局样式暴露很多，命名空间缺乏混乱，造成**css**污染严重，**css**代码复用性较差

网站的**seo**问题：**1**网站**meta**中添加关键词，描述**2html**标签语义化，用**strong**比用**b**要好，**h1**一个页面只用一个 **nav**标签用作导航。

 **img**标签添加**alter**。这是一个很重要的标签，如果网站无法加载图片，会用文字代替图片，提高网站的可读性

这个版权符号不要使用特殊符号 &copy; 可以直接使用输入法，拼“banquan”，选择序号5就能打出版权符号©。

.谨慎使用 display：none ：对于不想显示的文字内容，应当设置z-index或设置到浏览器显示器之外。因为搜索引擎会过滤掉display:none其中的内容。

<a>标签：页内链接，要加 “title” 属性加以说明，让访客和 “蜘蛛” 知道。而外部链接，链接到其他网站的，则需要加上 el="nofollow" 属性, 告诉 “蜘蛛” 不要爬，因为一旦“蜘蛛”爬了外部链接之后，就不会再回来了

iframe：

说起这个标签普遍都是负面的评价，耗能高，安全性低，而且这个标签同样不会被搜索引擎抓取。

一个浏览器到底是如何工作的：

浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面；把请求回来的 HTML 代码经过解析，构建成 DOM 树；计算 DOM 树上的 CSS 属性；最后根据 CSS 属性对元素逐个进行渲染，得到内存中的位图；一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度；合成之后，再绘制到界面上。

HTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 在 TCP 的基础上，规定了 Request-Response 的模式。这个模式决定了通讯必定是由浏览器端首先发起的。

HTTP 是纯粹的文本协议，它是规定了使用 TCP 协议来传输文本格式的一个应用层协议。

HTTPS 是使用加密通道来传输 HTTP 的内容。但是 HTTPS 首先与服务端建立一条 TLS 加密通道。TLS 构建于 TCP 协议之上，它实际上是对传输的内容做一次加密，所以从传输内容上看，HTTPS 跟 HTTP 没有任何区别。

HTTP 2.0 最大的改进有两点，一是支持服务端推送，二是支持 TCP 连接复用。服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存当中，这可以避免客户端请求顺序带来的并行度不高，从而导致的性能问题。TCP 连接复用，则使用同一个 TCP 连接来传输多个 HTTP 请求，避免了 TCP 连接建立时的三次握手开销，和初建 TCP 连接时传输窗口小的问题。

304 又是一个每个前端必知必会的状态，产生这个状态的前提是：客户端本地已经有缓存的版本，并且在 Request 中告诉了服务端，当服务端通过时间或者 tag，发现没有更新的时候，就会返回一个不含 body 的 304 状态。

浏览器工程师要想实现把字符流解析成词（token），最常见的方案就是使用状态机。



性能问题可以分成很多方面，最重要的几个点是：页面加载性能；动画与操作性能；内存、电量消耗。

我们设计了一个新的指标——秒开率，即一秒之内打开的用户占用户总量的百分比

首先我们要简单分析一下，从输入 URL 后按下回车，到底发生了什么。

从域名到 IP 地址，需要用 DNS 协议查询；HTTP 协议是用 TCP 传输的，所以会有 TCP 建立连接过程；如果使用 HTTPS，还有有 HTTPS 交换证书；每个网页还有图片等请求。
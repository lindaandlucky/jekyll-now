# 网络通信

## 基于node的网络编程

​    面向网络而生

  事件驱动，无阻塞，单线程

   node 的API十分贴合网络，适合构建灵活的网络服务

  传统的web服务大多数需要专门的web服务器作为容器

  node方便搭建网络服务器

node提供了net,dgram,http,https四个模块，分别处理TCP,UDP,HTTp,HTTPS,适用于服务器端和客户端

Nunjucks ///模版引擎

jsonplaceHolder.// 在线接口测试

## node.js网络通信概述

网络5层模型

| 应用层     | 上层数据                                      |
| ---------- | --------------------------------------------- |
| 传输层     | TCP头部      上层数据                         |
| 网络层     | IP头部  TCP头部      上层数据                 |
| 数据链路层 | MAC头部    IP头部  TCP头部      上层数据 尾部 |
| 物理层     |                                               |

### 层与协议

每一层都是为了完成一种功能，为了实现这些功能，就需要大家都遵守共同的规则。

大家都遵守的规则，就叫做协议

互联网的每一层，都定义了很多协议。这些协议的总称，就叫做"互联网协议"，它们是互联网的核心

### 实体层

将电脑连起来的物理手段就叫做实体层，它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号

### 链接层

单纯的0和1没有任何意义，必须规定解读方式

这就是链接层的功能，他在实体层的上方，确定了0和1的分组方式

—以太网协议（包括标头和数据，标头中有一些说明项，以帧的方式发送，如果数据较多，多帧发送）

—MAC地址

  以太网数据包的标头，包含了发送者和接受者的信息。那么发送者和接受者是如何标识的呢

以太网固定，连入网络的所有设备，都必须具有"网卡接口"。数据包必须是从一块网卡，传送到另一块网卡。

网卡的地址，就是数据包的发送地址和接受地址，这就叫做MAC地址

----广播

以太网素举报必须知道接收方的MAC地址，然后才能发送

  首先，一块网卡怎么会知道另一块网卡的MAC地址

  其次，就算有了MAC地址，系统怎么才能把数据包准确送到接收方

回答： 以太网采用了一种很原始的方式，它不是将数据包准确送到接收方，而是向本网络内所有的计算机发送，让每台计算机自己判断，是否为接收方

### 网络层

互联网是无数子网络共同组成的一个巨型网络。广播的方式只存在于同一个子网络中，如果分布在不同的子网络，以太网提供的这种方式就不方便了

所以必须找到一个方法，能够区分哪些mac地址属于同一个子网络，哪些不是。如果在同一个子网络中，就采用广播方式发送，否则采用路由（向不同的子网络发送数据包）方式发送，但是Mac地址无法做到

这就导致了网络层的诞生，它的作用就是引进一套新的地址，使得我们能够区分不同的计算机书否属于同一子网络。这套地址就叫做网络地址，简称"网址"。

于是：网络层出现后，没太电脑就有了两种地址，一种是mac地址，另一种是网络地址。两种地址之间没有任何联系，mac地址是绑定在网卡上的，网络地址是管理员分配的，它们随机组合在一起。

网络地址帮助我们确定计算机所在的子网络（先处理），mac地址将数据包送到子网络的目标网卡

-----IP协议

  规定网络地址的协议，叫做IP协议，它所定义的地址，就被称为IP地址

作用：为每台 计算机分配一个Ip 地址，确定哪些地址在同一个子网络

### 传输层

-----端口号

我们需要一个参数，表示这个数据包到底是供哪个程序的，这个参数就是"端口"，它其实就是每一个使用网卡的程序的编号。每一个数据包都发到主机的特定端口，然后不同的程序就能取到自己所需要的数据

传输层的功能，就是建立"端口到端口"的通信，相比之下，"网络层"的功能是建立"主机到主机的通信"。只要驱丁主机和端口，我们就可以实现程序之间的交流。因此，unix系统将主机+端口号，叫做"套字节"（socket),有了它，就可以进行网络应用程序开发了

------UDP协议

现在我们在数据包中加入了端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面加上端口号

UDP数据包由标头和数据两部分组成

标头定义了发出端口和接受端口，数据部分就是具体内容，然后将整个UDP数据包放入IP数据包的数据部分，再将IP数据包放在以太网数据包中

———TCP协议（传输控制协议）

是一种面向连接的，可靠的，基于字节流的传输层通信协议

UDP协议不可靠，TCP协议保证了数据的可靠性

### 应用层

应用程序收到传输层的数据，接下来进行解读。

应用层的作用就是规定应用程序的数据格式

这是最高的一层，直接面对用户，它的数据就放在TCP数据包的数据部分，所以以太网的数据包就变成了这样

| Head   | Head | Head | Data   |
| ------ | ---- | ---- | ------ |
| 以太网 | iP   | TCP  | 应用层 |
| 标头   | 标头 | 标头 | 数据包 |

## 网络七层模型

| 应用层     | 为应用数据提供服务           |
| ---------- | ---------------------------- |
| 表示层     | 数据格式钻花，数据加密       |
| 会话层     | 建立，管理和维护会话         |
| 传输层     | 建立，管理和维护端到端的连接 |
| 网络层     | Ip选址及路由选择             |
| 数据链路层 | 提供介质访问和链路管理       |
| 物理层     | 物理层                       |

# 构建TCP服务

## 三次握手

客户端 和   服务端通过三次握手构建回话

tcp必须经过三次握手才能建立连接

tcp只负责数据的传输，不关心数据的传输格式的问题

如果需要tcp通信完成某种功能，需要制定数据格式协议，或者使用第三方协议

Socket就是与之通信的另一端，通过另一端接受或者发送数据

## 构建TCP服务

使用net模块构建TCP服务端和客户端

什么是数据格式？

数据格式是描述数据保存在文件或者记录中的规则，可以是字符形式的文本格式，也可以是二进制数据形式的压缩形式

比较常见的数据传输格式： json,xml,yaml

# 构建UDP服务

用户数据报协议

和Tcp一样，在网络传输层用于处理数据包

最大的特点是无连接

传输速度快

传输不可靠（可靠性是应用层负责的）

支持一对一通信，也支持一对多通信

很多关键的互联网应用程序使用udp(DNS)

适用于速度要求比较高的，对数据质量不严谨的应用（实时音频）

## UDP和tcp的区别

|          | UDP                       | TCP                    |
| -------- | ------------------------- | ---------------------- |
| 连接     | 无连接                    | 面向连接               |
| 速度     | 无需建立连接，速度较快    | 需要建立连接，速度较慢 |
| 目的主机 | 一对一，一对多            | 仅支持一对一           |
| 带宽     | UDP报头较短，消耗带宽较少 | 消耗更多的带宽         |
| 消息边界 | 有                        | 无                     |
| 可靠性   | 低                        | 高                     |
| 顺序     | 无序                      | 有序                   |

## UDP 的三种传输方式

1. UDP单播

   ​     点对点

2. UDP广播 

   目的地址就是网络中的所有设备   

3. UDP组播

​      目的地址就是一组目的地地址

node中提供dgram模块用于构建UDP服务

使用该模块创建UDP套接字非常简单，UDP套接字一旦创建，既可以作为客户端发送数据，也可以作为服务器接收数据

```js
const dgram = require('dgram')
const socket = dgram.createSocket('udp4')
```

**Socket方法**、

| API              | 说明                   |
| ---------------- | ---------------------- |
| bind()           | 绑定端口和主机         |
| address()        | 返回Socket地址对象     |
| close()          | 关闭Socket并停止监听   |
| send()           | 发送消息               |
| addMembership()  | 添加组播成员           |
| dropMembership() | 删除组播成员           |
| setBroadcast()   | 设置是否启动广播       |
| setTTL()         | 设置数据报生存时间     |
| setMulticastTTL  | 设置组播数据报生存时间 |

**Socket事件**

| API       | 说明                       |
| --------- | -------------------------- |
| listening | 监听成功时触发。仅触发一层 |
| message   | 收到消息时触发             |
| error     | 发生错误时出啊发           |
| close     | 关闭Socket时触发           |

# 构建http服务

基于经典的BS通信，基于传输层之上专门制定了更上一层的通信协议：http，用于浏览器和服务端进行通信，由于http协议本身不考虑数据如何传输及其他细节问题，所以属于应用层协议

node提供了基本的http和https模块用于http和https的封装

**server实例**

| API              | 说明               |
| ---------------- | ------------------ |
| Event:"close"    | 服务关闭时触发     |
| Event:"request"  | 收到请求消息时触发 |
| Server.close()   | 关闭服务           |
| Server.listening | 获取服务状态       |

**请求对象**

| API                 | 说明             |
| ------------------- | ---------------- |
| Request.method      | 请求方法         |
| Request.url         | 请求路径         |
| Request.headers     | 请求头           |
| Request.httpVersion | 请求http协议版本 |

**响应对象**

| API                               | 说明             |
| --------------------------------- | ---------------- |
| Response.end()                    | 结束响应         |
| Response.setHeader(name,value)    | 设置响应头       |
| Response.removeHeader(name,value) | 删除响应头       |
| Response.statusCode               | 设置响应状态码   |
| Response.statusMessage            | 设置响应状态短语 |
| Response.write()                  | 写入响应数据     |
| Response.writeHead()              | 写入响应头       |

**使用模版引擎处理动态页面**

模版引擎的介绍

​     识别特殊的语法标记进行字符串的解析替换

node中有很多模版引擎 marko nunjucks handlebars.js ejs pug art-template